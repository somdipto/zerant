From 06c3fcded5e2f84bde1d7d6bc88f135e00875621 Mon Sep 17 00:00:00 2001
From: Nikhil Sonti <nikhilsv92@gmail.com>
Date: Fri, 5 Sep 2025 10:33:27 -0700
Subject: [PATCH] browseros api updates v2: execute js, highlights, screenshot

---
 .../api/browser_os/browser_os_api.cc          | 317 ++++++++++++++--
 .../api/browser_os/browser_os_api.h           |  60 +++-
 .../api/browser_os/browser_os_api_helpers.cc  | 340 +++++++++++++++---
 .../api/browser_os/browser_os_api_helpers.h   |  25 +-
 .../api/browser_os/browser_os_api_utils.cc    |   2 +-
 .../api/browser_os/browser_os_api_utils.h     |   2 +
 .../browser_os_snapshot_processor.cc          |  78 +++-
 .../browser_os_snapshot_processor.h           |  27 +-
 .../chrome_extensions_browser_api_provider.cc |   1 +
 chrome/common/extensions/api/browser_os.idl   |  43 +++
 .../extension_function_histogram_value.h      |   3 +
 11 files changed, 786 insertions(+), 112 deletions(-)

diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api.cc b/chrome/browser/extensions/api/browser_os/browser_os_api.cc
index 5242a1c3f930c..8065045e17330 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api.cc
@@ -11,6 +11,7 @@
 #include <vector>
 
 #include "base/functional/bind.h"
+#include "base/threading/platform_thread.h"
 #include "chrome/browser/profiles/profile.h"
 #include "components/prefs/pref_service.h"
 #include "base/json/json_writer.h"
@@ -35,6 +36,7 @@
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/render_widget_host.h"
 #include "content/public/browser/render_widget_host_view.h"
+#include "content/browser/renderer_host/render_widget_host_view_base.h"
 #include "content/public/browser/web_contents.h"
 #include "third_party/blink/public/common/input/web_input_event.h"
 #include "third_party/blink/public/common/input/web_mouse_event.h"
@@ -178,6 +180,7 @@ ExtensionFunction::ResponseAction BrowserOSGetInteractiveSnapshotFunction::Run()
   }
   
   content::WebContents* web_contents = tab_info->web_contents;
+  web_contents_ = web_contents;  // Store for later use in OnSnapshotProcessed
   
   // Note: We don't need to get scale factors here!
   // The accessibility tree provides bounds in CSS pixels (logical pixels),
@@ -186,14 +189,19 @@ ExtensionFunction::ResponseAction BrowserOSGetInteractiveSnapshotFunction::Run()
   
   // Store tab ID for mapping
   tab_id_ = tab_info->tab_id;
-  
-  // Get viewport size
-  content::RenderWidgetHostView* rwhv = web_contents->GetRenderWidgetHostView();
-  if (rwhv) {
-    viewport_size_ = rwhv->GetVisibleViewportSize();
-    LOG(INFO) << "Viewport size: " << viewport_size_.ToString();
-  }
 
+  // Check frame stability before requesting snapshot
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh || !rfh->IsRenderFrameLive() || !rfh->IsActive()) {
+    LOG(WARNING) << "[browseros] Frame not stable for AX snapshot - skipping";
+    browser_os::InteractiveSnapshot empty_snapshot;
+    empty_snapshot.snapshot_id = next_snapshot_id_++;
+    empty_snapshot.timestamp = base::Time::Now().InMillisecondsFSinceUnixEpoch();
+    empty_snapshot.processing_time_ms = 0;
+    return RespondNow(ArgumentList(
+        browser_os::GetInteractiveSnapshot::Results::Create(empty_snapshot)));
+  }
+  
   // Request accessibility tree snapshot
   web_contents->RequestAXTreeSnapshot(
       base::BindOnce(
@@ -204,18 +212,43 @@ ExtensionFunction::ResponseAction BrowserOSGetInteractiveSnapshotFunction::Run()
       /* max_nodes= */ 0,  // No limit
       /* timeout= */ base::TimeDelta(),
       content::WebContents::AXTreeSnapshotPolicy::kAll);
+      // content::WebContents::AXTreeSnapshotPolicy::kSameOriginDirectDescendants);
 
   return RespondLater();
 }
 
 void BrowserOSGetInteractiveSnapshotFunction::OnAccessibilityTreeReceived(
     ui::AXTreeUpdate& tree_update) {
+  // Double-check frame is still valid before processing
+  if (!web_contents_) {
+    LOG(WARNING) << "[browseros] WebContents gone during AX snapshot callback";
+    browser_os::InteractiveSnapshot empty_snapshot;
+    empty_snapshot.snapshot_id = next_snapshot_id_++;
+    empty_snapshot.timestamp = base::Time::Now().InMillisecondsFSinceUnixEpoch();
+    empty_snapshot.processing_time_ms = 0;
+    Respond(ArgumentList(
+        browser_os::GetInteractiveSnapshot::Results::Create(empty_snapshot)));
+    return;
+  }
+  
+  content::RenderFrameHost* rfh = web_contents_->GetPrimaryMainFrame();
+  if (!rfh || !rfh->IsRenderFrameLive()) {
+    LOG(WARNING) << "[browseros] Frame became unstable during AX snapshot callback";
+    browser_os::InteractiveSnapshot empty_snapshot;
+    empty_snapshot.snapshot_id = next_snapshot_id_++;
+    empty_snapshot.timestamp = base::Time::Now().InMillisecondsFSinceUnixEpoch();
+    empty_snapshot.processing_time_ms = 0;
+    Respond(ArgumentList(
+        browser_os::GetInteractiveSnapshot::Results::Create(empty_snapshot)));
+    return;
+  }
+  
   // Simple API layer - just delegates to the processor
   SnapshotProcessor::ProcessAccessibilityTree(
       tree_update,
       tab_id_,
       next_snapshot_id_++,
-      viewport_size_,
+      web_contents_,
       base::BindOnce(
           &BrowserOSGetInteractiveSnapshotFunction::OnSnapshotProcessed,
           base::WrapRefCounted(this)));
@@ -620,10 +653,16 @@ ExtensionFunction::ResponseAction BrowserOSSendKeysFunction::Run() {
 
 // Implementation of BrowserOSCaptureScreenshotFunction
 
+BrowserOSCaptureScreenshotFunction::BrowserOSCaptureScreenshotFunction() = default;
+BrowserOSCaptureScreenshotFunction::~BrowserOSCaptureScreenshotFunction() = default;
+
 ExtensionFunction::ResponseAction BrowserOSCaptureScreenshotFunction::Run() {
   std::optional<browser_os::CaptureScreenshot::Params> params =
       browser_os::CaptureScreenshot::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params);
+  
+  // Store whether to show highlights
+  show_highlights_ = params->show_highlights.value_or(false);
 
   // Get the target tab
   std::string error_message;
@@ -635,6 +674,8 @@ ExtensionFunction::ResponseAction BrowserOSCaptureScreenshotFunction::Run() {
   }
   
   content::WebContents* web_contents = tab_info->web_contents;
+  web_contents_ = web_contents;
+  tab_id_ = tab_info->tab_id;
   
   // Get the render widget host view
   content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
@@ -655,51 +696,120 @@ ExtensionFunction::ResponseAction BrowserOSCaptureScreenshotFunction::Run() {
   // Get the view bounds to determine the size
   gfx::Rect view_bounds = rwhv->GetViewBounds();
   
-  // Determine max thumbnail size
-  // If thumbnailSize is provided, use minimum of it and viewport dimensions
-  // Otherwise, use viewport size (no scaling)
-  int max_dimension;
-  if (params->thumbnail_size) {
-    // Take minimum of requested size and viewport dimensions
-    int viewport_max = std::max(view_bounds.width(), view_bounds.height());
-    max_dimension = std::min(static_cast<int>(*params->thumbnail_size), viewport_max);
-    LOG(INFO) << "[browseros] CaptureScreenshot: Using thumbnail size: " << max_dimension 
-              << " (requested: " << *params->thumbnail_size 
-              << ", viewport max: " << viewport_max << ")";
+  // Check if exact width and height are specified
+  if (params->width && params->height) {
+    // Use exact dimensions without preserving aspect ratio
+    use_exact_dimensions_ = true;
+    target_size_ = gfx::Size(static_cast<int>(*params->width), 
+                            static_cast<int>(*params->height));
+    LOG(INFO) << "[browseros] CaptureScreenshot: Using exact dimensions: "
+              << target_size_.width() << "x" << target_size_.height();
   } else {
-    // No thumbnail size specified, use viewport dimensions
-    max_dimension = std::max(view_bounds.width(), view_bounds.height());
-    LOG(INFO) << "[browseros] CaptureScreenshot: Using viewport size: " << max_dimension;
+    // Fall back to original behavior with thumbnailSize
+    use_exact_dimensions_ = false;
+    
+    // Determine max thumbnail size
+    // If thumbnailSize is provided, use minimum of it and viewport dimensions
+    // Otherwise, use viewport size (no scaling)
+    int max_dimension;
+    if (params->thumbnail_size) {
+      // Take minimum of requested size and viewport dimensions
+      int viewport_max = std::max(view_bounds.width(), view_bounds.height());
+      max_dimension = std::min(static_cast<int>(*params->thumbnail_size), viewport_max);
+      LOG(INFO) << "[browseros] CaptureScreenshot: Using thumbnail size: " << max_dimension 
+                << " (requested: " << *params->thumbnail_size 
+                << ", viewport max: " << viewport_max << ")";
+    } else {
+      // No thumbnail size specified, use viewport dimensions
+      max_dimension = std::max(view_bounds.width(), view_bounds.height());
+      LOG(INFO) << "[browseros] CaptureScreenshot: Using viewport size: " << max_dimension;
+    }
+    
+    gfx::Size thumbnail_size = view_bounds.size();
+    
+    // Scale down proportionally if needed
+    if (thumbnail_size.width() > max_dimension || 
+        thumbnail_size.height() > max_dimension) {
+      float scale = std::min(
+          static_cast<float>(max_dimension) / thumbnail_size.width(),
+          static_cast<float>(max_dimension) / thumbnail_size.height());
+      thumbnail_size = gfx::ScaleToFlooredSize(thumbnail_size, scale);
+    }
+    
+    target_size_ = thumbnail_size;
   }
   
-  gfx::Size thumbnail_size = view_bounds.size();
+  // Store target size for later use
+  
+  // Draw highlights first, then capture after a short delay
+  DrawHighlightsAndCapture();
   
-  // Scale down proportionally if needed
-  if (thumbnail_size.width() > max_dimension || 
-      thumbnail_size.height() > max_dimension) {
-    float scale = std::min(
-        static_cast<float>(max_dimension) / thumbnail_size.width(),
-        static_cast<float>(max_dimension) / thumbnail_size.height());
-    thumbnail_size = gfx::ScaleToFlooredSize(thumbnail_size, scale);
+  return RespondLater();
+}
+
+void BrowserOSCaptureScreenshotFunction::DrawHighlightsAndCapture() {
+  // Only draw highlights if requested via the showHighlights flag
+  if (show_highlights_) {
+    // Check if we have snapshot data for this tab to draw highlights
+    auto tab_it = GetNodeIdMappings().find(tab_id_);
+    if (tab_it != GetNodeIdMappings().end() && !tab_it->second.empty()) {
+      LOG(INFO) << "[browseros] Drawing highlights for screenshot with " 
+                << tab_it->second.size() << " interactive elements";
+      ShowHighlights(web_contents_, tab_it->second, true /* show_labels */);
+    } else {
+      LOG(INFO) << "[browseros] No snapshot data available for highlighting";
+    }
+    
+    // Use PostDelayedTask to allow the renderer to paint the highlights
+    // This lets the event loop run and process the DOM changes
+    // Use scoped_refptr to keep the function alive
+    base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+        FROM_HERE,
+        base::BindOnce(&BrowserOSCaptureScreenshotFunction::CaptureScreenshotNow,
+                       base::WrapRefCounted(this)),
+        base::Milliseconds(1000));  // Give enough time for JS execution and paint
+  } else {
+    // No highlights needed, capture immediately
+    CaptureScreenshotNow();
+  }
+}
+
+void BrowserOSCaptureScreenshotFunction::CaptureScreenshotNow() {
+  if (!web_contents_) {
+    Respond(Error("Web contents destroyed"));
+    return;
+  }
+  
+  content::RenderFrameHost* rfh = web_contents_->GetPrimaryMainFrame();
+  if (!rfh) {
+    Respond(Error("No render frame"));
+    return;
+  }
+  
+  content::RenderWidgetHost* rwh = rfh->GetRenderWidgetHost();
+  if (!rwh) {
+    Respond(Error("No render widget host"));
+    return;
   }
   
-  // For macOS, we need to use a different approach since GrabWindowSnapshot
-  // expects a window, not a view. Let's use CopyFromSurface instead.
   content::RenderWidgetHostImpl* rwhi = 
       static_cast<content::RenderWidgetHostImpl*>(rwh);
   
-  // Request a copy of the surface
+  // Request the screenshot
   rwhi->GetView()->CopyFromSurface(
       gfx::Rect(),  // Empty rect means copy entire surface
-      thumbnail_size,
+      target_size_,
       base::BindOnce(&BrowserOSCaptureScreenshotFunction::OnScreenshotCaptured,
                      this));
-  
-  return RespondLater();
 }
 
 void BrowserOSCaptureScreenshotFunction::OnScreenshotCaptured(
     const SkBitmap& bitmap) {
+  // Clean up the highlights immediately after capture (only if we added them)
+  if (show_highlights_ && web_contents_) {
+    RemoveHighlights(web_contents_);
+  }
+  
   if (bitmap.empty()) {
     Respond(Error("Failed to capture screenshot"));
     return;
@@ -1011,5 +1121,140 @@ ExtensionFunction::ResponseAction BrowserOSGetVersionNumberFunction::Run() {
       browser_os::GetVersionNumber::Results::Create(version)));
 }
 
+// BrowserOSExecuteJavaScriptFunction
+ExtensionFunction::ResponseAction BrowserOSExecuteJavaScriptFunction::Run() {
+  std::optional<browser_os::ExecuteJavaScript::Params> params =
+      browser_os::ExecuteJavaScript::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Get the target tab
+  std::string error_message;
+  auto tab_info = GetTabFromOptionalId(params->tab_id, browser_context(),
+                                       include_incognito_information(),
+                                       &error_message);
+  if (!tab_info) {
+    return RespondNow(Error(error_message));
+  }
+  
+  content::WebContents* web_contents = tab_info->web_contents;
+  
+  // Get the primary main frame
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh) {
+    return RespondNow(Error("No render frame"));
+  }
+  
+  LOG(INFO) << "[browseros] ExecuteJavaScript: Executing code in tab " << tab_info->tab_id;
+  
+  // Convert JavaScript code string to UTF16
+  std::u16string js_code = base::UTF8ToUTF16(params->code);
+  
+  // Execute the JavaScript code using ExecuteJavaScriptForTests
+  // This will return the result of the execution
+  rfh->ExecuteJavaScriptForTests(
+      js_code,
+      base::BindOnce(&BrowserOSExecuteJavaScriptFunction::OnJavaScriptExecuted,
+                     this),
+      /*honor_js_content_settings=*/false);
+  
+  return RespondLater();
+}
+
+void BrowserOSExecuteJavaScriptFunction::OnJavaScriptExecuted(base::Value result) {
+  LOG(INFO) << "[browseros] ExecuteJavaScript: Execution completed";
+
+  if (result.is_none()) {
+      // JavaScript returned undefined or execution failed
+      // Return an empty object instead of NONE to satisfy the validator
+      result = base::Value(base::Value::Type::DICT);
+  }
+  
+  // Return the result directly
+  Respond(ArgumentList(
+      browser_os::ExecuteJavaScript::Results::Create(result)));
+}
+
+// Implementation of BrowserOSClickCoordinatesFunction
+ExtensionFunction::ResponseAction BrowserOSClickCoordinatesFunction::Run() {
+  std::optional<browser_os::ClickCoordinates::Params> params =
+      browser_os::ClickCoordinates::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Get the target tab
+  std::string error_message;
+  auto tab_info = GetTabFromOptionalId(params->tab_id, browser_context(),
+                                       include_incognito_information(),
+                                       &error_message);
+  if (!tab_info) {
+    LOG(ERROR) << "[browseros] ClickCoordinates: " << error_message;
+    browser_os::InteractionResponse response;
+    response.success = false;
+    return RespondNow(ArgumentList(
+        browser_os::ClickCoordinates::Results::Create(response)));
+  }
+  
+  content::WebContents* web_contents = tab_info->web_contents;
+  
+  // Create the click point from the coordinates
+  gfx::PointF click_point(params->x, params->y);
+  
+  LOG(INFO) << "[browseros] ClickCoordinates: Clicking at (" 
+            << params->x << ", " << params->y << ")";
+  
+  // Perform the click with change detection
+  bool success = ClickCoordinatesWithDetection(web_contents, click_point);
+  
+  // Prepare the response
+  browser_os::InteractionResponse response;
+  response.success = success;
+  
+  LOG(INFO) << "[browseros] ClickCoordinates: Result = " 
+            << (success ? "success" : "no change detected");
+  
+  return RespondNow(ArgumentList(
+      browser_os::ClickCoordinates::Results::Create(response)));
+}
+
+// Implementation of BrowserOSTypeAtCoordinatesFunction  
+ExtensionFunction::ResponseAction BrowserOSTypeAtCoordinatesFunction::Run() {
+  std::optional<browser_os::TypeAtCoordinates::Params> params =
+      browser_os::TypeAtCoordinates::Params::Create(args());
+  EXTENSION_FUNCTION_VALIDATE(params);
+
+  // Get the target tab
+  std::string error_message;
+  auto tab_info = GetTabFromOptionalId(params->tab_id, browser_context(),
+                                       include_incognito_information(),
+                                       &error_message);
+  if (!tab_info) {
+    LOG(ERROR) << "[browseros] TypeAtCoordinates: " << error_message;
+    browser_os::InteractionResponse response;
+    response.success = false;
+    return RespondNow(ArgumentList(
+        browser_os::TypeAtCoordinates::Results::Create(response)));
+  }
+  
+  content::WebContents* web_contents = tab_info->web_contents;
+  
+  // Create the click point from the coordinates
+  gfx::PointF click_point(params->x, params->y);
+  
+  LOG(INFO) << "[browseros] TypeAtCoordinates: Clicking at (" 
+            << params->x << ", " << params->y << ") and typing: " << params->text;
+  
+  // Perform the click and type operation
+  bool success = TypeAtCoordinatesWithDetection(web_contents, click_point, params->text);
+  
+  // Prepare the response
+  browser_os::InteractionResponse response;
+  response.success = success;
+  
+  LOG(INFO) << "[browseros] TypeAtCoordinates: Result = " 
+            << (success ? "success" : "failed");
+  
+  return RespondNow(ArgumentList(
+      browser_os::TypeAtCoordinates::Results::Create(response)));
+}
+
 }  // namespace api
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api.h b/chrome/browser/extensions/api/browser_os/browser_os_api.h
index 27721d9b0b9a0..51ba01b900769 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api.h
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api.h
@@ -7,6 +7,7 @@
 
 #include <cstdint>
 
+#include "base/memory/raw_ptr.h"
 #include "base/values.h"
 #include "chrome/browser/extensions/api/browser_os/browser_os_api_utils.h"
 #include "chrome/browser/extensions/api/browser_os/browser_os_content_processor.h"
@@ -66,8 +67,8 @@ class BrowserOSGetInteractiveSnapshotFunction : public ExtensionFunction {
   // Tab ID for storing mappings
   int tab_id_ = -1;
   
-  // Viewport size for checking visibility
-  gfx::Size viewport_size_;
+  // Web contents for processing and drawing
+  raw_ptr<content::WebContents> web_contents_ = nullptr;
 };
 
 class BrowserOSClickFunction : public ExtensionFunction {
@@ -179,16 +180,25 @@ class BrowserOSCaptureScreenshotFunction : public ExtensionFunction {
  public:
   DECLARE_EXTENSION_FUNCTION("browserOS.captureScreenshot", BROWSER_OS_CAPTURESCREENSHOT)
 
-  BrowserOSCaptureScreenshotFunction() = default;
+  BrowserOSCaptureScreenshotFunction();
 
  protected:
-  ~BrowserOSCaptureScreenshotFunction() override = default;
+  ~BrowserOSCaptureScreenshotFunction() override;
 
   // ExtensionFunction:
   ResponseAction Run() override;
   
  private:
+  void DrawHighlightsAndCapture();
+  void CaptureScreenshotNow();
   void OnScreenshotCaptured(const SkBitmap& bitmap);
+  
+  // Store web contents and tab id for highlight operations
+  raw_ptr<content::WebContents> web_contents_ = nullptr;
+  int tab_id_ = -1;
+  gfx::Size target_size_;
+  bool show_highlights_ = false;
+  bool use_exact_dimensions_ = false;
 };
 
 class BrowserOSGetSnapshotFunction : public ExtensionFunction {
@@ -275,6 +285,48 @@ class BrowserOSGetVersionNumberFunction : public ExtensionFunction {
   ResponseAction Run() override;
 };
 
+class BrowserOSExecuteJavaScriptFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("browserOS.executeJavaScript", BROWSER_OS_EXECUTEJAVASCRIPT)
+
+  BrowserOSExecuteJavaScriptFunction() = default;
+
+ protected:
+  ~BrowserOSExecuteJavaScriptFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+  
+ private:
+  void OnJavaScriptExecuted(base::Value result);
+};
+
+class BrowserOSClickCoordinatesFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("browserOS.clickCoordinates", BROWSER_OS_CLICKCOORDINATES)
+
+  BrowserOSClickCoordinatesFunction() = default;
+
+ protected:
+  ~BrowserOSClickCoordinatesFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
+class BrowserOSTypeAtCoordinatesFunction : public ExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("browserOS.typeAtCoordinates", BROWSER_OS_TYPEATCOORDINATES)
+
+  BrowserOSTypeAtCoordinatesFunction() = default;
+
+ protected:
+  ~BrowserOSTypeAtCoordinatesFunction() override = default;
+
+  // ExtensionFunction:
+  ResponseAction Run() override;
+};
+
 }  // namespace api
 }  // namespace extensions
 
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc
index d05a75dd626e9..b8555289c07f9 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h"
 
 #include "base/strings/string_number_conversions.h"
+#include "base/strings/stringprintf.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/task/sequenced_task_runner.h"
 #include "chrome/browser/extensions/api/browser_os/browser_os_api_utils.h"
@@ -68,36 +69,18 @@ float CssToWidgetScale(content::WebContents* web_contents,
   return zoom * css_zoom * page_scale;
 }
 
-// Helper function to get center point of a node's bounds in CSS pixels.
-// On HiDPI (e.g., macOS Retina), normalize physical pixels by DSF so the
-// returned point aligns with document CSS coordinates used for visualization.
+// Helper function to get center point of a node's bounds.
+// Bounds are already stored in CSS pixels from SnapshotProcessor,
+// so no DSF conversion is needed.
 gfx::PointF GetNodeCenterPoint(content::WebContents* web_contents,
                                const NodeInfo& node_info) {
-  gfx::PointF center(node_info.bounds.x() + node_info.bounds.width() / 2.0f,
-                     node_info.bounds.y() + node_info.bounds.height() / 2.0f);
-
-  if (!web_contents)
-    return center;
-
-  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
-  if (!rfh)
-    return center;
-  content::RenderWidgetHost* rwh = rfh->GetRenderWidgetHost();
-  if (!rwh)
-    return center;
-  if (auto* view_any = rwh->GetView()) {
-    if (auto* view_base =
-            static_cast<content::RenderWidgetHostViewBase*>(view_any)) {
-      const float dsf = view_base->GetDeviceScaleFactor();
-      if (dsf > 0.0f && dsf != 1.0f) {
-        center.set_x(center.x() / dsf);
-        center.set_y(center.y() / dsf);
-      }
-    }
-  }
-  return center;
+  // Simple calculation - bounds are already in CSS pixels
+  return gfx::PointF(
+      node_info.bounds.x() + node_info.bounds.width() / 2.0f,
+      node_info.bounds.y() + node_info.bounds.height() / 2.0f);
 }
 
+
 // Helper function to visualize a human-like cursor click.
 // Shows an orange cursor triangle with ripple effect that moves to the target.
 // This uses CSS transitions/animations and cleans itself up automatically.
@@ -119,7 +102,7 @@ void VisualizeInteractionPoint(content::WebContents* web_contents,
   const float start_y = point.y() - (sin(angle) * distance);
   
   // Build the JavaScript code using string concatenation to avoid format string issues
-  std::string js_code = absl::StrFormat(
+  std::string js_code = base::StringPrintf(
       R"(
       (function() {
         var COLOR = '#FC661A';
@@ -262,7 +245,7 @@ void PointClick(content::WebContents* web_contents,
   gfx::PointF widget_point(css_point.x() * scale, css_point.y() * scale);
 
   // Visualize the actual target location on the page (CSS pixel coords).
-  VisualizeInteractionPoint(web_contents, css_point, 2000, 50.0f);
+  // VisualizeInteractionPoint(web_contents, css_point, 2000, 50.0f);
 
   // Create mouse down event
   blink::WebMouseEvent mouse_down;
@@ -794,10 +777,17 @@ bool ClickWithDetection(content::WebContents* web_contents,
     base::PlatformThread::Sleep(base::Milliseconds(300));
     
     // For out-of-viewport nodes, use AccessibilityDoDefault first (most reliable after scroll)
-    LOG(INFO) << "[browseros] Node was out of viewport, trying AccessibilityDoDefault click first";
+    // LOG(INFO) << "[browseros] Node was out of viewport, trying AccessibilityDoDefault click first";
+    // bool changed = BrowserOSChangeDetector::ExecuteWithDetection(
+    //     web_contents,
+    //     [&]() { AccessibilityDoDefault(web_contents, node_info); },
+    //     base::Milliseconds(300));
+    
+    gfx::PointF click_point = GetNodeCenterPoint(web_contents, node_info);
+    
     bool changed = BrowserOSChangeDetector::ExecuteWithDetection(
         web_contents,
-        [&]() { AccessibilityDoDefault(web_contents, node_info); },
+        [&]() { PointClick(web_contents, click_point); },
         base::Milliseconds(300));
     
     if (!changed) {
@@ -900,15 +890,15 @@ bool TypeWithDetection(content::WebContents* web_contents,
   }
   
   // If still no change, try accessibility SetValue as final fallback
-  if (!changed) {
-    LOG(INFO) << "[browseros] No change from JavaScript, trying accessibility SetValue";
-    changed = BrowserOSChangeDetector::ExecuteWithDetection(
-        web_contents,
-        [&]() {
-          AccessibilitySetValue(web_contents, node_info, text);
-        },
-        base::Milliseconds(300));
-  }
+  // if (!changed) {
+  //   LOG(INFO) << "[browseros] No change from JavaScript, trying accessibility SetValue";
+  //   changed = BrowserOSChangeDetector::ExecuteWithDetection(
+  //       web_contents,
+  //       [&]() {
+  //         AccessibilitySetValue(web_contents, node_info, text);
+  //       },
+  //       base::Milliseconds(300));
+  // }
   
   LOG(INFO) << "[browseros] Type result: " << (changed ? "changed" : "no change");
   return changed;
@@ -918,10 +908,10 @@ bool TypeWithDetection(content::WebContents* web_contents,
 bool ClearWithDetection(content::WebContents* web_contents,
                        const NodeInfo& node_info) {
   // Get center point for visualization
-  gfx::PointF clear_point = GetNodeCenterPoint(web_contents, node_info);
+  // gfx::PointF clear_point = GetNodeCenterPoint(web_contents, node_info);
   
   // Visualize where we're about to clear (orange for clear)
-  VisualizeInteractionPoint(web_contents, clear_point, 2000, 50.0f);
+  // VisualizeInteractionPoint(web_contents, clear_point, 2000, 50.0f);
   
   // Use change detection with JavaScript clear
   bool changed = BrowserOSChangeDetector::ExecuteWithDetection(
@@ -971,5 +961,273 @@ bool KeyPressWithDetection(content::WebContents* web_contents,
   return changed;
 }
 
+// Helper to show highlights for clickable, typeable, and selectable elements that are in viewport
+void ShowHighlights(
+    content::WebContents* web_contents,
+    const std::unordered_map<uint32_t, NodeInfo>& node_mappings,
+    bool show_labels) {
+  
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh) return;
+  
+  // Filter nodes to only include:
+  // 1. Elements that are in viewport (using stored in_viewport field)
+  // 2. Elements that are clickable, typeable, or selectable (using stored node_type)
+  std::unordered_map<uint32_t, NodeInfo> filtered_nodes;
+  
+  for (const auto& [node_id, node_info] : node_mappings) {
+    // Check if element is in viewport using the stored field
+    if (!node_info.in_viewport) {
+      continue;  // Skip elements not in viewport
+    }
+    
+    // Check if element is clickable, typeable, or selectable using stored node_type
+    // Skip "other" interactive type as requested
+    if (node_info.node_type == browser_os::InteractiveNodeType::kClickable ||
+        node_info.node_type == browser_os::InteractiveNodeType::kTypeable ||
+        node_info.node_type == browser_os::InteractiveNodeType::kSelectable) {
+      filtered_nodes[node_id] = node_info;
+    }
+  }
+  
+  // If no nodes match our criteria, return early
+  if (filtered_nodes.empty()) {
+    LOG(INFO) << "[browseros] No interactive elements in viewport to highlight";
+    return;
+  }
+  
+  LOG(INFO) << "[browseros] Highlighting " << filtered_nodes.size() 
+            << " interactive elements in viewport (out of " << node_mappings.size() << " total)";
+  
+  // Use the original drawing implementation but with filtered nodes
+  
+  // Build JavaScript to draw all bounding boxes at once
+  std::string js_code = R"(
+    (function() {
+      // Remove any existing bounding boxes
+      document.querySelectorAll('.browseros-bbox').forEach(e => e.remove());
+      
+      // Create container for all bounding boxes
+      const container = document.createElement('div');
+      container.className = 'browseros-bbox-container';
+      container.style.cssText = `
+        position: fixed;
+        top: 0;
+        left: 0;
+        width: 100%;
+        height: 100%;
+        pointer-events: none;
+        z-index: 2147483647;
+      `;
+      
+      // Node data with bounds
+      const nodes = [
+  )";
+  
+  // Add filtered nodes with their bounds
+  bool first = true;
+  for (const auto& [node_id, node_info] : filtered_nodes) {
+    if (!first) js_code += ",";
+    first = false;
+    
+    // Bounds are already in CSS pixels from SnapshotProcessor
+    js_code += base::StringPrintf(
+        R"(
+        {
+          id: %d,
+          x: %f,
+          y: %f,
+          width: %f,
+          height: %f,
+          role: "%s"
+        })",
+        node_id,
+        node_info.bounds.x(),
+        node_info.bounds.y(),
+        node_info.bounds.width(),
+        node_info.bounds.height(),
+        node_info.attributes.count("role") ? node_info.attributes.at("role").c_str() : "unknown"
+    );
+  }
+  
+  js_code += R"(
+      ];
+      
+      // Draw bounding boxes for all nodes in parallel
+      nodes.forEach(node => {
+        if (node.width <= 0 || node.height <= 0) return;
+        
+        const box = document.createElement('div');
+        box.className = 'browseros-bbox';
+        box.dataset.nodeId = node.id;
+        box.style.cssText = `
+          position: absolute;
+          left: ${node.x}px;
+          top: ${node.y}px;
+          width: ${node.width}px;
+          height: ${node.height}px;
+          border: 2px solid #1E40AF;
+          background: transparent;
+          box-sizing: border-box;
+        `;
+  )";
+  
+  if (show_labels) {
+    js_code += R"(
+        // Add label with node ID
+        const label = document.createElement('div');
+        label.style.cssText = `
+          position: absolute;
+          top: -22px;
+          left: 0;
+          background: #2563EB;
+          color: #FFFFFF;
+          padding: 3px 7px;
+          font-size: 14px;
+          font-family: monospace;
+          border-radius: 3px;
+          white-space: nowrap;
+          opacity: 0.9;
+        `;
+        label.textContent = node.id;
+        box.appendChild(label);
+    )";
+  }
+  
+  js_code += R"(
+        container.appendChild(box);
+      });
+      
+      document.body.appendChild(container);
+      
+      // Return count for verification
+      return nodes.length;
+    })();
+  )";
+  
+  // Execute the JavaScript
+  rfh->ExecuteJavaScriptForTests(
+      base::UTF8ToUTF16(js_code),
+      base::NullCallback(),
+      false);
+}
+
+// Helper to remove all bounding box highlights from the page
+void RemoveHighlights(content::WebContents* web_contents) {
+  content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+  if (!rfh) return;
+  
+  // JavaScript to remove all bounding box containers
+  std::string js_code = R"(
+    (function() {
+      // Remove all bounding box containers
+      document.querySelectorAll('.browseros-bbox-container').forEach(e => e.remove());
+      document.querySelectorAll('.browseros-bbox').forEach(e => e.remove());
+      
+      // Remove all highlight containers  
+      document.querySelectorAll('.browseros-highlight-container').forEach(e => e.remove());
+      document.querySelectorAll('.browseros-highlight').forEach(e => e.remove());
+      
+      // Remove any style elements we added
+      document.querySelectorAll('#browseros-highlight-styles').forEach(e => e.remove());
+      
+      return true;
+    })();
+  )";
+  
+  rfh->ExecuteJavaScriptForTests(
+      base::UTF8ToUTF16(js_code),
+      base::NullCallback(),
+      false);
+}
+
+// Helper to click at specific coordinates with change detection
+bool ClickCoordinatesWithDetection(content::WebContents* web_contents,
+                                   const gfx::PointF& point) {
+  LOG(INFO) << "[browseros] ClickCoordinatesWithDetection at (" 
+            << point.x() << ", " << point.y() << ")";
+  
+  // Perform coordinate click with change detection
+  bool changed = BrowserOSChangeDetector::ExecuteWithDetection(
+      web_contents,
+      [&]() { 
+        PointClick(web_contents, point);
+        // Optionally visualize the click point
+        // VisualizeInteractionPoint(web_contents, point, 1500);
+      },
+      base::Milliseconds(300));
+  
+  LOG(INFO) << "[browseros] Click coordinates result: " 
+            << (changed ? "changed" : "no change");
+  return changed;
+}
+
+// Helper to type text after clicking at coordinates to focus element
+bool TypeAtCoordinatesWithDetection(content::WebContents* web_contents,
+                                    const gfx::PointF& point,
+                                    const std::string& text) {
+  LOG(INFO) << "[browseros] TypeAtCoordinatesWithDetection at (" 
+            << point.x() << ", " << point.y() << ") with text: " << text;
+  
+  // First click at the coordinates to focus the element
+  PointClick(web_contents, point);
+  
+  // Visualize the click point briefly
+  // VisualizeInteractionPoint(web_contents, point, 1000);
+  
+  // Wait a moment for focus to be established
+  base::PlatformThread::Sleep(base::Milliseconds(100));
+  
+  // Now type the text with change detection
+  bool changed = BrowserOSChangeDetector::ExecuteWithDetection(
+      web_contents,
+      [&]() { 
+        NativeType(web_contents, text);
+      },
+      base::Milliseconds(300));
+  
+  // If native typing didn't work, try JavaScript injection to detect and type
+  if (!changed) {
+    LOG(INFO) << "[browseros] No change from native typing at coordinates, trying JS injection";
+    
+    // Execute JavaScript to find the focused element and set its value
+    content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame();
+    if (rfh) {
+      std::string js_code = base::StringPrintf(R"(
+        (function() {
+          var focused = document.activeElement;
+          if (focused && (focused.tagName === 'INPUT' || 
+                         focused.tagName === 'TEXTAREA' || 
+                         focused.contentEditable === 'true')) {
+            if (focused.contentEditable === 'true') {
+              focused.textContent = '%s';
+            } else {
+              focused.value = '%s';
+            }
+            // Trigger input event
+            focused.dispatchEvent(new Event('input', { bubbles: true }));
+            focused.dispatchEvent(new Event('change', { bubbles: true }));
+            return true;
+          }
+          return false;
+        })();
+      )", text.c_str(), text.c_str());
+      
+      rfh->ExecuteJavaScriptForTests(
+          base::UTF8ToUTF16(js_code),
+          base::NullCallback(),
+          false);
+      
+      // Give it a moment to register
+      base::PlatformThread::Sleep(base::Milliseconds(50));
+      changed = true; // Assume success if we reached here
+    }
+  }
+  
+  LOG(INFO) << "[browseros] Type at coordinates result: " 
+            << (changed ? "success" : "failed");
+  return changed;
+}
+
 }  // namespace api
 }  // namespace extensions
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h
index b5fd204753973..434ddabfec46b 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_helpers.h
@@ -28,8 +28,8 @@ struct NodeInfo;
 float CssToWidgetScale(content::WebContents* web_contents,
                        content::RenderWidgetHost* rwh);
 
-// Returns the center point of a node's bounds in CSS pixels, normalized by
-// device scale factor when necessary so it aligns with document coordinates.
+// Returns the center point of a node's bounds.
+// Bounds are already in CSS pixels from SnapshotProcessor.
 gfx::PointF GetNodeCenterPoint(content::WebContents* web_contents,
                                const NodeInfo& node_info);
 
@@ -118,6 +118,27 @@ void VisualizeInteractionPoint(content::WebContents* web_contents,
                                int duration_ms = 3000,
                                float offset_range = 50.0f);
 
+// Helper to show highlights for clickable, typeable, and selectable elements that are in viewport
+// Only highlights elements that are actually visible and interactable
+void ShowHighlights(content::WebContents* web_contents,
+                                 const std::unordered_map<uint32_t, NodeInfo>& node_mappings,
+                                 bool show_labels = true);
+
+// Helper to remove all bounding box highlights from the page
+void RemoveHighlights(content::WebContents* web_contents);
+
+// Helper to click at specific coordinates with change detection
+// Returns true if the click caused a detectable change in the page
+bool ClickCoordinatesWithDetection(content::WebContents* web_contents,
+                                   const gfx::PointF& point);
+
+// Helper to type text after clicking at coordinates to focus element
+// First clicks at the coordinates to focus an element, then types the text
+// Returns true if the operation succeeded
+bool TypeAtCoordinatesWithDetection(content::WebContents* web_contents,
+                                    const gfx::PointF& point,
+                                    const std::string& text);
+
 }  // namespace api
 }  // namespace extensions
 
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc
index eccf01b1f9280..0c3a060fc70de 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.cc
@@ -20,7 +20,7 @@ namespace extensions {
 namespace api {
 
 // NodeInfo implementation
-NodeInfo::NodeInfo() : ax_node_id(0), ax_tree_id() {}
+NodeInfo::NodeInfo() : ax_node_id(0), ax_tree_id(), node_type(browser_os::InteractiveNodeType::kOther), in_viewport(false) {}
 NodeInfo::~NodeInfo() = default;
 NodeInfo::NodeInfo(const NodeInfo&) = default;
 NodeInfo& NodeInfo::operator=(const NodeInfo&) = default;
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h
index c632dc7a71585..f4fdcb73186cd 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h
+++ b/chrome/browser/extensions/api/browser_os/browser_os_api_utils.h
@@ -50,6 +50,8 @@ struct NodeInfo {
   ui::AXTreeID ax_tree_id;  // Tree ID for change detection
   gfx::RectF bounds;  // Absolute bounds in CSS pixels
   std::unordered_map<std::string, std::string> attributes;  // All computed attributes
+  browser_os::InteractiveNodeType node_type;  // Cached node type to avoid recomputation
+  bool in_viewport;  // Whether the node is currently visible in viewport
 };
 
 // Global node ID mappings storage
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc b/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc
index 8dfc0cce77512..885942336dcd6 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc
+++ b/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.cc
@@ -24,6 +24,9 @@
 #include "base/time/time.h"
 #include "chrome/browser/extensions/api/browser_os/browser_os_api_utils.h"
 #include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "content/browser/renderer_host/render_widget_host_view_base.h"
+#include "content/public/browser/web_contents.h"
 #include "ui/accessibility/ax_clipping_behavior.h"
 #include "ui/accessibility/ax_coordinate_system.h"
 #include "ui/accessibility/ax_enum_util.h"
@@ -40,16 +43,17 @@
 namespace extensions {
 namespace api {
 
-// Static method to compute bounds for a node using AXTree
+// Static method to compute bounds for a node using AXTree and convert to CSS pixels
 // This implements the same logic as BrowserAccessibility::GetBoundsRect
-gfx::Rect SnapshotProcessor::GetNodeBounds(
+gfx::RectF SnapshotProcessor::GetNodeBounds(
     ui::AXTree* tree,
     const ui::AXNode* node,
     const ui::AXCoordinateSystem coordinate_system,
     const ui::AXClippingBehavior clipping_behavior,
+    float device_scale_factor,
     bool* out_offscreen) {
   if (!tree || !node) {
-    return gfx::Rect();
+    return gfx::RectF();
   }
   
   // Start with empty bounds (same as GetBoundsRect does)
@@ -65,17 +69,16 @@ gfx::Rect SnapshotProcessor::GetNodeBounds(
     *out_offscreen = offscreen;
   }
   
-  // For frame coordinates, we're done
-  // We use kFrame since we want viewport-relative coordinates
-  if (coordinate_system == ui::AXCoordinateSystem::kFrame) {
-    return gfx::ToEnclosingRect(bounds);
+  // Convert physical pixels to CSS pixels
+  if (device_scale_factor > 0.0f && device_scale_factor != 1.0f) {
+    bounds.set_x(bounds.x() / device_scale_factor);
+    bounds.set_y(bounds.y() / device_scale_factor);
+    bounds.set_width(bounds.width() / device_scale_factor);
+    bounds.set_height(bounds.height() / device_scale_factor);
   }
   
-  // For root frame or screen coordinates, additional transformations would be needed
-  // but for our use case (click coordinates), frame coordinates are what we need
-  // since ForwardMouseEvent expects viewport-relative coordinates
-  
-  return gfx::ToEnclosingRect(bounds);
+  // Return bounds in CSS pixels
+  return bounds;
 }
 
 
@@ -139,6 +142,8 @@ struct SnapshotProcessor::ProcessingContext
   std::unique_ptr<ui::AXTree> ax_tree;  // AXTree for computing accurate bounds
   int tab_id;
   ui::AXTreeID tree_id;  // Tree ID for change detection
+  float device_scale_factor = 1.0f;  // For converting physical to CSS pixels
+  gfx::Size viewport_size;  // For visibility checks
   base::TimeTicks start_time;
   size_t total_nodes;
   size_t processed_batches;
@@ -317,7 +322,8 @@ std::vector<SnapshotProcessor::ProcessedNode> SnapshotProcessor::ProcessNodeBatc
     const std::vector<ui::AXNodeData>& nodes_to_process,
     const std::unordered_map<int32_t, ui::AXNodeData>& node_map,
     ui::AXTree* ax_tree,
-    uint32_t start_node_id) {
+    uint32_t start_node_id,
+    float device_scale_factor) {
   std::vector<ProcessedNode> results;
   results.reserve(nodes_to_process.size());
   
@@ -353,8 +359,8 @@ std::vector<SnapshotProcessor::ProcessedNode> SnapshotProcessor::ProcessNodeBatc
     if (ax_tree) {
       ui::AXNode* ax_node = ax_tree->GetFromId(node_data.id);
       if (ax_node) {
-        // Get bounds in frame coordinates (viewport-relative CSS pixels)
-        gfx::Rect bounds = GetNodeBounds(
+        // GetNodeBounds now returns CSS pixels directly
+        data.absolute_bounds = GetNodeBounds(
             ax_tree, 
             ax_node,
             ui::AXCoordinateSystem::kFrame,
@@ -362,11 +368,11 @@ std::vector<SnapshotProcessor::ProcessedNode> SnapshotProcessor::ProcessNodeBatc
             // scrolled/clip containers. This matches how clicks should target
             // on-screen rects.
             ui::AXClippingBehavior::kClipped,
+            device_scale_factor,  // Pass DSF for CSS pixel conversion
             &is_offscreen);
-        data.absolute_bounds = gfx::RectF(bounds);
         
         VLOG(3) << "[browseros] Node " << node_data.id 
-                << " computed bounds: " << bounds.ToString()
+                << " CSS bounds: " << data.absolute_bounds.ToString()
                 << " offscreen: " << is_offscreen;
       } else {
         // Node not found in AXTree, skip bounds computation
@@ -420,6 +426,10 @@ void SnapshotProcessor::OnBatchProcessed(
     info.ax_tree_id = context->tree_id;  // Store tree ID for change detection
     info.bounds = node_data.absolute_bounds;
     info.attributes = node_data.attributes;  // Store all computed attributes
+    info.node_type = node_data.node_type;  // Store node type for efficient filtering
+    // Extract in_viewport from attributes (stored as "true"/"false" string)
+    auto viewport_it = node_data.attributes.find("in_viewport");
+    info.in_viewport = (viewport_it != node_data.attributes.end() && viewport_it->second == "true");
     GetNodeIdMappings()[context->tab_id][node_data.node_id] = info;
     
     // Log the mapping for debugging
@@ -490,14 +500,41 @@ void SnapshotProcessor::OnBatchProcessed(
 }
 
 // Main processing function
+// Helper function to extract viewport info from WebContents
+// Returns viewport size and device scale factor
+static std::pair<gfx::Size, float> ExtractViewportInfo(
+    content::WebContents* web_contents) {
+  gfx::Size viewport_size;
+  float device_scale_factor = 1.0f;
+  
+  if (web_contents) {
+    if (auto* rwhv = web_contents->GetRenderWidgetHostView()) {
+      viewport_size = rwhv->GetVisibleViewportSize();
+      
+      // Get device scale factor for CSS pixel conversion
+      if (auto* rwhv_base = 
+          static_cast<content::RenderWidgetHostViewBase*>(rwhv)) {
+        device_scale_factor = rwhv_base->GetDeviceScaleFactor();
+      }
+    }
+  }
+  
+  LOG(INFO) << "[browseros] Viewport: " << viewport_size.ToString() 
+            << ", DSF: " << device_scale_factor;
+  
+  return {viewport_size, device_scale_factor};
+}
+
 void SnapshotProcessor::ProcessAccessibilityTree(
     const ui::AXTreeUpdate& tree_update,
     int tab_id,
     uint32_t snapshot_id,
-    const gfx::Size& viewport_size,
+    content::WebContents* web_contents,
     base::OnceCallback<void(SnapshotProcessingResult)> callback) {
   base::TimeTicks start_time = base::TimeTicks::Now();
   
+  // Extract viewport info from WebContents on UI thread
+  auto [viewport_size, device_scale_factor] = ExtractViewportInfo(web_contents);
   
   // Build node ID map, parent map and children map for efficient lookup
   std::unordered_map<int32_t, ui::AXNodeData> node_map;
@@ -540,6 +577,8 @@ void SnapshotProcessor::ProcessAccessibilityTree(
   context->parent_map = std::move(parent_map); 
   context->children_map = std::move(children_map);
   context->ax_tree = std::move(ax_tree);  // Store AXTree for bounds computation
+  context->device_scale_factor = device_scale_factor;  // For CSS pixel conversion
+  context->viewport_size = viewport_size;  // For visibility checks
   context->start_time = start_time;
   
   // Store the tree ID for change detection
@@ -597,7 +636,8 @@ void SnapshotProcessor::ProcessAccessibilityTree(
                        std::move(batch), 
                        context->node_map,
                        context->ax_tree.get(),  // Pass AXTree pointer for bounds computation
-                       start_node_id),
+                       start_node_id,
+                       context->device_scale_factor),  // Pass DSF for CSS pixel conversion
         base::BindOnce(&SnapshotProcessor::OnBatchProcessed,
                        context));
   }
diff --git a/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.h b/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.h
index 2c14673b4d1c1..5c85cd73b26f3 100644
--- a/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.h
+++ b/chrome/browser/extensions/api/browser_os/browser_os_snapshot_processor.h
@@ -15,6 +15,10 @@
 #include "chrome/common/extensions/api/browser_os.h"
 #include "ui/gfx/geometry/rect_f.h"
 
+namespace content {
+class WebContents;
+}  // namespace content
+
 namespace ui {
 class AXNode;
 class AXTree;
@@ -60,33 +64,38 @@ class SnapshotProcessor {
 
   // Main processing function - handles all threading internally
   // This function processes the accessibility tree into an interactive snapshot
-  // using parallel processing on the thread pool.
+  // using parallel processing on the thread pool. Extracts viewport info from
+  // web_contents on UI thread before processing.
   static void ProcessAccessibilityTree(
       const ui::AXTreeUpdate& tree_update,
       int tab_id,
       uint32_t snapshot_id,
-      const gfx::Size& viewport_size,
+      content::WebContents* web_contents,
       base::OnceCallback<void(SnapshotProcessingResult)> callback);
 
   // Process a batch of nodes (exposed for testing)
   // The ax_tree is used to compute accurate bounds for each node
+  // device_scale_factor is used to convert physical pixels to CSS pixels
   static std::vector<ProcessedNode> ProcessNodeBatch(
       const std::vector<ui::AXNodeData>& nodes_to_process,
       const std::unordered_map<int32_t, ui::AXNodeData>& node_map,
       ui::AXTree* ax_tree,
-      uint32_t start_node_id);
+      uint32_t start_node_id,
+      float device_scale_factor = 1.0f);
 
  private:
   // Internal processing context
   struct ProcessingContext;
   
-  // Compute absolute bounds for a node using AXTree
+  // Compute absolute bounds for a node using AXTree and convert to CSS pixels
   // This implements the same logic as BrowserAccessibility::GetBoundsRect
-  static gfx::Rect GetNodeBounds(ui::AXTree* tree, 
-                                  const ui::AXNode* node,
-                                  const ui::AXCoordinateSystem coordinate_system,
-                                  const ui::AXClippingBehavior clipping_behavior,
-                                  bool* out_offscreen = nullptr);
+  // Returns bounds in CSS pixels by applying device_scale_factor
+  static gfx::RectF GetNodeBounds(ui::AXTree* tree, 
+                                   const ui::AXNode* node,
+                                   const ui::AXCoordinateSystem coordinate_system,
+                                   const ui::AXClippingBehavior clipping_behavior,
+                                   float device_scale_factor = 1.0f,
+                                   bool* out_offscreen = nullptr);
   
   // Batch processing callback
   static void OnBatchProcessed(scoped_refptr<ProcessingContext> context,
diff --git a/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc b/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
index 6b3227c786686..3666bf5a0d2c8 100644
--- a/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
+++ b/chrome/browser/extensions/chrome_extensions_browser_api_provider.cc
@@ -28,6 +28,7 @@ void ChromeExtensionsBrowserAPIProvider::RegisterExtensionFunctions(
   registry->RegisterFunction<api::BrowserOSClickFunction>();
   registry->RegisterFunction<api::BrowserOSInputTextFunction>();
   registry->RegisterFunction<api::BrowserOSClearFunction>();
+  registry->RegisterFunction<api::BrowserOSExecuteJavaScriptFunction>();
 
   // Generated APIs from Chrome.
   api::ChromeGeneratedFunctionRegistry::RegisterAll(registry);
diff --git a/chrome/common/extensions/api/browser_os.idl b/chrome/common/extensions/api/browser_os.idl
index a8cbf0250d19a..23de5b35d5043 100644
--- a/chrome/common/extensions/api/browser_os.idl
+++ b/chrome/common/extensions/api/browser_os.idl
@@ -177,6 +177,9 @@ namespace browserOS {
   
   // Callback for getting version number
   callback GetVersionNumberCallback = void(DOMString version);
+  
+  // Callback for executeJavaScript
+  callback ExecuteJavaScriptCallback = void(any result);
 
   interface Functions {
     // Gets the full accessibility tree for a tab
@@ -276,15 +279,46 @@ namespace browserOS {
         optional long tabId,
         DOMString key,
         InteractionCallback callback);
+    
+    // Clicks at specific coordinates on the page
+    // |tabId|: The tab to click in. Defaults to active tab.
+    // |x|: X coordinate in CSS pixels from viewport origin.
+    // |y|: Y coordinate in CSS pixels from viewport origin.
+    // |callback|: Called when the click is complete.
+    static void clickCoordinates(
+        optional long tabId,
+        double x,
+        double y,
+        InteractionCallback callback);
+    
+    // Types text after clicking at coordinates to focus element
+    // |tabId|: The tab to type in. Defaults to active tab.
+    // |x|: X coordinate to click for focus.
+    // |y|: Y coordinate to click for focus.
+    // |text|: Text to type after focusing.
+    // |callback|: Called when the operation is complete.
+    static void typeAtCoordinates(
+        optional long tabId,
+        double x,
+        double y,
+        DOMString text,
+        InteractionCallback callback);
         
     // Captures a screenshot of the tab as a thumbnail
     // |tabId|: The tab to capture. Defaults to active tab.
     // |thumbnailSize|: Optional max dimension for the thumbnail. If not provided, uses viewport size.
     //                  The actual size will be the minimum of this value and the viewport dimensions.
+    //                  Ignored if width and height are specified.
+    // |showHighlights|: If true, shows bounding boxes around clickable, typeable, and selectable elements that are in viewport.
+    // |width|: Optional exact width for screenshot. When used with height, overrides thumbnailSize.
+    // |height|: Optional exact height for screenshot. When used with width, overrides thumbnailSize.
     // |callback|: Called with the screenshot as a data URL.
     static void captureScreenshot(
         optional long tabId,
         optional long thumbnailSize,
+        optional boolean showHighlights,
+        optional long width,
+        optional long height,
         CaptureScreenshotCallback callback);
 
     // Gets a content snapshot of the specified type from the page
@@ -335,6 +369,15 @@ namespace browserOS {
     // |callback|: Called with the version string.
     static void getVersionNumber(
         GetVersionNumberCallback callback);
+    
+    // Executes JavaScript code in the specified tab
+    // |tabId|: The tab to execute JavaScript in. Defaults to active tab.
+    // |code|: The JavaScript code to execute.
+    // |callback|: Called with the result of the execution.
+    static void executeJavaScript(
+        optional long tabId,
+        DOMString code,
+        ExecuteJavaScriptCallback callback);
   };
 };
 
diff --git a/extensions/browser/extension_function_histogram_value.h b/extensions/browser/extension_function_histogram_value.h
index 4ba734b8f5f0e..804539041fa01 100644
--- a/extensions/browser/extension_function_histogram_value.h
+++ b/extensions/browser/extension_function_histogram_value.h
@@ -2015,6 +2015,9 @@ enum HistogramValue {
   BROWSER_OS_GETALLPREFS = 1952,
   BROWSER_OS_LOGMETRIC = 1953,
   BROWSER_OS_GETVERSIONNUMBER = 1954,
+  BROWSER_OS_EXECUTEJAVASCRIPT = 1955,
+  BROWSER_OS_CLICKCOORDINATES = 1956,
+  BROWSER_OS_TYPEATCOORDINATES = 1957,
   // Last entry: Add new entries above, then run:
   // tools/metrics/histograms/update_extension_histograms.py
   ENUM_BOUNDARY
-- 
2.49.0

